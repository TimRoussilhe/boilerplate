@mixin responsive-font($responsive, $min, $max: false, $fallback: false) {
  $responsive-unitless: $responsive / ($responsive - $responsive + 1);
  $dimension: if(unit($responsive) == 'vh', 'height', 'width');
  $min-breakpoint: $min / $responsive-unitless * 100;

  @media (max-#{$dimension}: #{$min-breakpoint}) {
    font-size: $min;
  }

  @if $max {
    $max-breakpoint: $max / $responsive-unitless * 100;

    @media (min-#{$dimension}: #{$max-breakpoint}) {
      font-size: $max;
    }
  }

  @if $fallback {
    font-size: $fallback;
  }

  font-size: $responsive;
}

/*
 * $size: size in pixel you want to have at $breakpoint
 * $min-size: min size of the responsive font: doesn't go smaller
 * $breakpoint: breakpoint to start using responsive fontSize
 */
@mixin fontSize($size, $breakpoint, $min-size: false) {
	// value for vw
	$responsive: $size * 100 / $breakpoint;

	// min value
  @if $min-size {
		$min-width: ($min-size * 100) / $responsive;

		@media screen and (max-width: #{$min-width} * 1px) {
		  font-size: $min-size * 1px;
		}
	}

	font-size: $responsive * 1vw;
}

/*
 * Styles a <textarea> with horizontal line rules
 * $line-height: px value of textarea's line-height
 * $rule-height: px value of desired rule height
 * $rule-color: desired color of horizontal rules
 */
@mixin multiline-input($line-height, $rule-height, $rule-color) {
    background-image: linear-gradient(from top, transparent, transparent $line-height, $rule-color 0);
    background-image: -ms-linear-gradient(top, transparent, transparent $line-height, $rule-color 0);
    background-image: -o-linear-gradient(top, transparent, transparent $line-height, $rule-color 0);
    background-image: -moz-linear-gradient(top, transparent, transparent $line-height, $rule-color 0);
    background-image: -webkit-linear-gradient(top, transparent, transparent $line-height, $rule-color 0);
    background-size: 100% $line-height + $rule-height;
    line-height: $line-height;

    resize: none;
    -moz-appearance: none;
    -webkit-appearance: none;
    appearance: none;
}

@mixin replaceText() {
    display: block;
    text-indent: -99999px;
}

@mixin tracking($val, $font-size) {
  letter-spacing: ( $val * $font-size / 1000 ) * 1px;
}

@mixin photoshop-letterspacing-to-ems($val) {
  letter-spacing: ( $val / 1000 ) * 1em;
}

// custom scrollbar
@mixin scrollbar($size, $foreground-color, $background-color: rgba($foreground-color, 0.25)) {
  // For Google Chrome
  &::-webkit-scrollbar {
      width:  $size;
      height: $size;
  }

  &::-webkit-scrollbar-thumb {
      background: $foreground-color;
  }

  &::-webkit-scrollbar-track {
      background: $background-color;
  }

  // For Internet Explorer
  &{
    scrollbar-face-color: $foreground-color;
    scrollbar-track-color: $background-color;
  }
}

@function responsive-font($breakpoint, $px) {
  @return #{$px*100/$breakpoint}vw;
}

// simple function to get back rem value;
// in our case body is set to 62.5% so our base font-size is a 10 multiple
@function get-rem($font-size) {
    @return $font-size/10 * 1rem;
}

// helper function to make sure the unit type (px, rem)
// is removed we want just the raw value no unit
@function get-value($n) {
    @return $n / ($n * 0 + 1);
}

// return ratio line-height / font-size
@function unitless-lh($font-size, $line-height) {
   @return get-value($line-height / $font-size);
}
// Usage:
// .foo {
//     font-size: 26px;
//     line-height: get-line-height(26px, 32px); //1.23077
// }

// mixins for use to easily input Font Style Guide
// px is optional too!
// letter spacing is optional for some edge cases
@mixin fontStyle($font-size, $line-height, $letter-spacing:"") {

  font-size: get-rem(get-value($font-size));
  line-height: unitless-lh($font-size, $line-height);

  //basic check for letter spacing
  @if $letter-spacing != "" {
    @if unit($letter-spacing) == 'px' {
      letter-spacing: $letter-spacing;
    }@else if unit($letter-spacing) == 'em' {
      letter-spacing: $letter-spacing;
    }@else{
      letter-spacing: $letter-spacing * 1px;
    }
  }
};
